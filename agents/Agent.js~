
class Agent {
    constructor(name, id, begin = Date.now(), repeat = 3600000, downstream_agent = null){
	this.name = name;
	this.id = id;
	this.repeat = repeat
	this.begin = begin
	this.repeatId = null;
	this.isRunning = false;
	this.downstream_agent = downstream_agent
    }

    start() {
	if (this.isRunning) {
	    console.log(`Agent [${this.name}: ${this.id}] is already running.`)
	    return
	}

	this.isRunning = true;
	    console.log(`Agent [${this.name}: ${this.id}] - starting...`)

	// Include the setTimeout, setInterval here
	if(this.repeat != null){
	    this.repeatId = this.perform_periodically()
	}
	else{
	    this.run()
	}
    }
	
    stop() {

	if (!this.isRunning) {
	    console.log(`Agent [${this.name}: ${this.id}] is not running.`)
	    return; 
	}

	clearInterval(this.repeatId)
	this.isRunning = false;
	    console.log(`Agent [${this.name}: ${this.id}] is stopped.`)
    }

    perform_periodically() {
	const currentTime = Date.now()
	let startTime = currentTime

	if (this.begin < currentTime) {
	    // If we're already passed the start time, calculate the next
	    // incrementing time
	    startTime = (currentTime - this.begin) % this.repeat
	}
	else {
	    // Otherwise, calculate the wait to the start time
	    startTime = this.begin - currentTime
	}
	// Use a timeout so we start the interval at the correct time
	// Then the interval manages itself
	let id = setTimeout(() => {
	    this.run()
	    return setInterval(x => {
		this.run()
	    }, this.repeat)
	}, startTime)

	return id;
    }


    // Methods to overrided
    describe(){

	return `This is boilerplate text from the Agent class. This should be
                overridden with a description of the Agent that extends this class`
    }

    async run() {
	console.warn(`Agent [${this.name}: ${this.id}] run() method not implemented.`);
    }

    async receive(data){
	console.warn(`Agent [${this.name}: ${this.id}] receive() method not implemented.`);
    }
    
    async send_downstream(data){

	if(!this.downstream_agent){
	    console.warn(`Agent [${this.name}: ${this.id}] does not have a downstream agent.`);
	    return
	}
	this.downstream_agent.receive(data)
	
    }


}

module.exports = Agent;
